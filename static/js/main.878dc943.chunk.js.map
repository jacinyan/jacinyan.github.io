{"version":3,"sources":["hooks/_helpers.ts","hooks/auth.ts","contexts/AuthContext.tsx","app/components/common/FullPageLoader.tsx","app/components/common/FullPageError.tsx","utils/index.ts","hooks/reorder.ts","hooks/api.ts","app/components/common/ErrorBox.tsx","app/components/common/Profiler.tsx","app/components/common/ErrorBoundary.tsx","app/App.tsx","contexts/index.tsx","reportWebVitals.ts","index.tsx","api/index.ts"],"names":["useMount","callback","useEffect","useSafeDispatch","dispatch","mountedRef","useRef","current","useMountedRef","useCallback","useDebounce","params","timeout","useState","debouncedParams","setDebouncedParams","timeoutId","setTimeout","clearTimeout","useDocumentTitle","title","persistOnUnmount","defaultTitle","document","useURLSearchParams","keys","useSearchParams","searchParams","setSearchParams","useSetSearchParams","stateKeys","useMemo","subset","Object","fromEntries","newSearchParams","removeEmptyQueryValues","useAuth","context","useContext","AuthContext","Error","bootstrapUser","a","user","token","getToken","configureFetch","data","createContext","undefined","displayName","AuthProvider","children","useAsyncTask","error","isError","isLoading","isIdle","asyncRun","setUser","setData","queryClient","useQueryClient","Provider","value","login","form","authLogin","then","register","authRegister","logout","authLogout","clear","FullPageLoader","style","display","height","justifyContent","alignItems","size","FullPageError","object","newObject","forEach","key","isVoid","resetRoutes","window","location","href","origin","obj","filteredEntries","entries","filter","includes","reorder","fromId","type","referenceId","list","copiedList","movingItemIndex","findIndex","item","id","insertAfter","length","targetIndex","insertBefore","from","to","toItem","removedItem","splice","toIndex","indexOf","useConfigureFetch","endpoint","config","initialState","status","initialConfig","throwOnError","useReducer","state","action","safeDispatch","retry","setRetry","setError","promise","asyncRunConfig","Promise","reject","isSuccess","useQueriesConfig","queryKey","onSuccess","invalidateQueries","onMutate","target","cancelQueries","prevItems","getQueryData","setQueryData","old","onError","newItem","onSettled","useCreateQueryConfig","useEditQueryConfig","map","useDeleteQueryConfig","useReorderSwimlaneQueryConfig","useReorderTaskQueryConfig","swimlaneId","toSwimlaneId","ErrorBox","message","Text","_queue","Profiler","metadata","phases","restProps","onRender","phase","actualDuration","baseDuration","startTime","commitTime","interactions","push","setInterval","console","count","_queueToSend","log","ErrorBoundary","this","props","fallbackRender","Component","AuthenticatedApp","React","lazy","UnauthenticatedApp","App","className","Suspense","fallback","AppProviders","QueryClient","defaultOptions","queries","refetchOnWindowFocus","QueryClientProvider","client","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","loadServer","ReactDOM","render","StrictMode","getElementById","api_URL","process","localStorageKey","headers","restConfig","method","Authorization","toUpperCase","qs","stringify","body","JSON","fetch","response","ok","json","reload","localStorage","getItem","handleUserResponse","setItem","removeItem"],"mappings":"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","file":"static/js/main.878dc943.chunk.js","sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { URLSearchParamsInit, useSearchParams } from \"react-router-dom\";\nimport { removeEmptyQueryValues, subset } from \"utils\";\n\nexport const useMount = (callback: () => void) => {\n  useEffect(() => {\n    callback();\n  }, [callback]);\n};\n\n//returns the status that indicates whether or not a comp is mounted, false by default\nexport const useMountedRef = () => {\n  const mountedRef = useRef(false);\n\n  useEffect(() => {\n    mountedRef.current = true;\n    return () => {\n      mountedRef.current = false;\n    };\n  });\n\n  return mountedRef;\n};\n\nexport const useSafeDispatch = <T>(dispatch: (...args: T[]) => void) => {\n  const mountedRef = useMountedRef();\n  return useCallback(\n    (...args: T[]) => (mountedRef.current ? dispatch(...args) : void 0),\n    [dispatch, mountedRef]\n  );\n};\n\nexport const useDebounce = <P>(params: P, timeout?: number) => {\n  const [debouncedParams, setDebouncedParams] = useState(params);\n\n  useEffect(() => {\n    const timeoutId = setTimeout(() => {\n      setDebouncedParams(params);\n    }, timeout);\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [params, timeout]);\n\n  return debouncedParams;\n};\n\nexport const useDocumentTitle = (title: string, persistOnUnmount = false) => {\n  const defaultTitle = useRef(document.title).current;\n  //loading: prevTitle\n  //onUnmount: a new title\n\n  useEffect(() => {\n    document.title = title;\n  }, [title, defaultTitle, persistOnUnmount]);\n\n  useEffect(() => {\n    return () => {\n      if (!persistOnUnmount) {\n        document.title = defaultTitle;\n      }\n    };\n  }, [persistOnUnmount, defaultTitle]);\n};\n\n// accesses the values of given input specific keys, and eventually returns these key-value pairs in the form of objects and a method.\nexport const useURLSearchParams = <K extends string>(keys: K[]) => {\n  const [searchParams] = useSearchParams();\n  //calling another custom hook, only whom controls the state of search params\n  const setSearchParams = useSetSearchParams();\n  //memoized keys from input, e.g. projectCreate, editingProjectId...\n  const [stateKeys] = useState(keys);\n\n  return [\n    useMemo(\n      () =>\n        subset(Object.fromEntries(searchParams), stateKeys) as {\n          [key in K]: string;\n        },\n      [searchParams, stateKeys]\n    ),\n    //instead of a plain 'set' method, this func is to restrict the type of input params to a narrower range of string literals depending on the keys in the generic K so that only the input keys in useURLSearchParams are valid whenever setSearchParams is called\n    (params: Partial<{ [key in K]: unknown }>) => {\n      return setSearchParams(params);\n    },\n  ] as const;\n};\n\n// only this hooks is able to manipulate the state of searchParams instead of multiple entries\nexport const useSetSearchParams = () => {\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  return (params: { [key in string]: unknown }) => {\n    const newSearchParams = removeEmptyQueryValues({\n      //transforms the searchParams iterable(array) into an object with the iterator interface\n      ...Object.fromEntries(searchParams),\n      ...params,\n    }) as URLSearchParamsInit;\n    return setSearchParams(newSearchParams);\n  };\n};\n","import { useContext } from \"react\";\nimport { AuthContext } from \"contexts/AuthContext\";\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error(\"useAuth must be used within an AuthProvider\");\n  }\n  return context;\n};\n","//infinitely simplified simulation of a 3rd party auth provider\nimport { createContext, ReactNode, useCallback } from \"react\";\nimport { useQueryClient } from \"react-query\";\nimport {\n  getToken,\n  configureFetch,\n  login as authLogin,\n  register as authRegister,\n  logout as authLogout,\n} from \"api\";\nimport { useAsyncTask } from \"hooks/api\";\nimport { useMount } from \"hooks/_helpers\";\nimport { User } from \"types\";\nimport FullPageLoader from \"app/components/common/FullPageLoader\";\nimport FullPageError from \"app/components/common/FullPageError\";\n\ninterface AuthForm {\n  username: string;\n  password: string;\n}\n\n//pre-loads the user log in/out state for persistency\nconst bootstrapUser = async () => {\n  let user = null;\n  //fetches token from localStorage\n  const token = getToken();\n  if (token) {\n    //specifies the token instead of calling the useConfigureFetch hook for general purposes\n    const data = await configureFetch(\"me\", { token });\n    user = data.user;\n  }\n  return user;\n};\n\nexport const AuthContext =\n  //avoids the value type in AuthProvider being undefined from default when it is obviously not\n  createContext<\n    | {\n        user: User | null;\n        register: (form: AuthForm) => Promise<void>;\n        login: (form: AuthForm) => Promise<void>;\n        logout: () => Promise<void>;\n      }\n    | undefined\n  >(undefined);\nAuthContext.displayName = \"AuthContext\";\n\nexport const AuthProvider = ({ children }: { children: ReactNode }) => {\n  const {\n    data: user,\n    error,\n    isError,\n    isLoading,\n    isIdle,\n    asyncRun,\n    setData: setUser,\n  } = useAsyncTask<User | null>();\n  //include queryClient in the context on top of existing async handlers for later use\n  const queryClient = useQueryClient();\n\n  //point free for (user)=> setUser(user)\n  const login = (form: AuthForm) => authLogin(form).then(setUser);\n  const register = (form: AuthForm) => authRegister(form).then(setUser);\n  const logout = () =>\n    authLogout().then(() => {\n      setUser(null);\n      queryClient.clear();\n    });\n\n  //checks token whenever the app mounts\n  useMount(\n    useCallback(() => {\n      asyncRun(bootstrapUser());\n    }, [asyncRun])\n  );\n\n  return isIdle || isLoading ? (\n    <FullPageLoader />\n  ) : isError ? (\n    <FullPageError error={error} />\n  ) : (\n    <AuthContext.Provider\n      value={{ user, login, register, logout }}\n      children={children}\n    />\n  );\n};\n","import { Spin } from \"antd\";\n\nconst FullPageLoader = (): JSX.Element => {\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        height: \"100vh\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n      }}\n    >\n      <Spin size=\"large\" />\n    </div>\n  );\n};\n\nexport default FullPageLoader;\n","import { DevTools } from \"typezilla-mockserver\";\nimport ErrorBox from \"app/components/common/ErrorBox\";\n\nconst FullPageError = ({ error }: { error?: Error | null }): JSX.Element => {\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        height: \"100vh\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n      }}\n    >\n      <DevTools />\n      <ErrorBox error={error} />\n    </div>\n  );\n};\n\nexport default FullPageError;\n","export const isFalsy = (value: unknown) => (value === 0 ? false : !value);\n\nexport const isVoid = (value: unknown) =>\n  value === undefined || value === null || value === \"\";\n\nexport const removeEmptyQueryValues = (object?: { [key: string]: unknown }) => {\n  if (!object) {\n    return {};\n  }\n\n  const newObject = { ...object };\n  Object.keys(newObject).forEach((key) => {\n    const value = newObject[key];\n    if (isVoid(value)) {\n      delete newObject[key];\n    }\n  });\n\n  return newObject;\n};\n\nexport const resetRoutes = () =>\n  (window.location.href = window.location.origin);\n\n/**\n * inputs an object and returns a corresponding key-value pair\n * @param obj\n * @param keys\n */\nexport const subset = <\n  O extends { [key in string]: unknown },\n  K extends keyof O\n>(\n  obj: O,\n  keys: K[]\n) => {\n  const filteredEntries = Object.entries(obj).filter(([key]) =>\n    keys.includes(key as K)\n  );\n  return Object.fromEntries(filteredEntries) as Pick<O, K>;\n};\n","/**\n * optimistic updates on the client side\n * @param fromId source id\n * @param type 'before' | 'after'\n * @param referenceId destination id\n * @param list target list, e.g. tasks, swimlanes\n */\nexport const reorder = ({\n  fromId,\n  type,\n  referenceId,\n  list,\n}: {\n  list: { id: number }[];\n  fromId: number;\n  type: \"after\" | \"before\";\n  referenceId: number;\n}) => {\n  const copiedList = [...list];\n  // find the index of fromId\n  const movingItemIndex = copiedList.findIndex((item) => item.id === fromId);\n  if (!referenceId) {\n    return insertAfter([...copiedList], movingItemIndex, copiedList.length - 1);\n  }\n  const targetIndex = copiedList.findIndex((item) => item.id === referenceId);\n  const insert = type === \"after\" ? insertAfter : insertBefore;\n  return insert([...copiedList], movingItemIndex, targetIndex);\n};\n\n/**\n * put 'from' before 'to' in a list\n * @param list\n * @param from\n * @param to\n */\nconst insertBefore = (list: unknown[], from: number, to: number) => {\n  const toItem = list[to];\n  const removedItem = list.splice(from, 1)[0];\n  const toIndex = list.indexOf(toItem);\n  list.splice(toIndex, 0, removedItem);\n  return list;\n};\n\n/**\n * put 'from' after 'to' in a list\n * @param list\n * @param from\n * @param to\n */\nconst insertAfter = (list: unknown[], from: number, to: number) => {\n  const toItem = list[to];\n  const removedItem = list.splice(from, 1)[0];\n  const toIndex = list.indexOf(toItem);\n  list.splice(toIndex + 1, 0, removedItem);\n  return list;\n};\n","import { useCallback, useReducer, useState } from \"react\";\nimport { QueryKey, useQueryClient } from \"react-query\";\nimport { useAuth } from \"./auth\";\nimport { configureFetch } from \"api\";\nimport { AsyncState, Task } from \"types\";\nimport { useSafeDispatch } from \"./_helpers\";\nimport { reorder } from \"./reorder\";\n\n//simply for the use of useAuth so that a token can be embedded if it exists, when $fetch is instantiated from configureFetch\nexport const useConfigureFetch = () => {\n  const { user } = useAuth();\n\n  return useCallback(\n    (...[endpoint, config]: Parameters<typeof configureFetch>) =>\n      configureFetch(endpoint, { ...config, token: user?.token }),\n    [user?.token]\n  );\n};\n\nexport const useAsyncTask = <D>(\n  initialState: AsyncState<D> = {\n    status: \"idle\",\n    data: null,\n    error: null,\n  },\n  initialConfig = { throwOnError: false }\n) => {\n  const [state, dispatch] = useReducer(\n    (state: AsyncState<D>, action: Partial<AsyncState<D>>) => ({\n      ...state,\n      ...action,\n    }),\n    {\n      ...initialState,\n    }\n  );\n  const config = { ...initialConfig };\n  //prevents no ops after comps being unmounted\n  const safeDispatch = useSafeDispatch(dispatch);\n  //refreshes on updates using lazy initialization, but here we are to cache a function\n  const [retry, setRetry] = useState(() => () => {});\n\n  const setData = useCallback(\n    (data: D) =>\n      safeDispatch({\n        data,\n        status: \"success\",\n        error: null,\n      }),\n    [safeDispatch]\n  );\n\n  const setError = useCallback(\n    (error: Error) =>\n      safeDispatch({\n        error,\n        status: \"error\",\n        data: null,\n      }),\n    [safeDispatch]\n  );\n\n  //triggers async code;\n  //asyncRunConfig to retrigger async code on updates automatically\n  const asyncRun = useCallback(\n    async (\n      promise: Promise<D>,\n      asyncRunConfig?: { retry: () => Promise<D> }\n    ) => {\n      if (!promise || !promise.then) {\n        throw new Error(\"Please pass in a Promise type \");\n      }\n      //recursive calls\n      setRetry(() => () => {\n        if (asyncRunConfig?.retry) {\n          asyncRun(asyncRunConfig?.retry(), asyncRunConfig);\n        }\n      });\n\n      safeDispatch({ status: \"loading\" });\n\n      try {\n        const data = await promise;\n        setData(data);\n        return data;\n      } catch (error) {\n        setError(error);\n        //throw errors in case of being swallowed by the catch block\n        if (config.throwOnError) {\n          return Promise.reject(error);\n        }\n        return error;\n      }\n    },\n    [config.throwOnError, setData, setError, safeDispatch]\n  );\n\n  return {\n    isIdle: state.status === \"idle\",\n    isLoading: state.status === \"loading\",\n    isError: state.status === \"error\",\n    isSuccess: state.status === \"success\",\n    setData,\n    setError,\n    asyncRun,\n    retry,\n    ...state,\n  };\n};\n\n//Queries factory with all other methods except 'GET', where onMutate is also configured for optimistic updates\nexport const useQueriesConfig = (\n  queryKey: QueryKey,\n  //given the complexity of the types in here , the infamous 'any' has to show up a lot of times :(\n  //yet optimistic updates is an isolated feature so we can live with that\n  callback: (target: any, old?: any[]) => any[]\n) => {\n  //create queryClient\n  const queryClient = useQueryClient();\n\n  return {\n    onSuccess: () => queryClient.invalidateQueries(queryKey),\n    //https://react-query.tanstack.com/guides/optimistic-updates\n    onMutate: async (target: any) => {\n      await queryClient.cancelQueries(queryKey);\n\n      const prevItems = queryClient.getQueryData(queryKey);\n\n      //for multiple queries\n      queryClient.setQueryData(queryKey, (old?: any[]) => {\n        return callback(target, old);\n      });\n\n      return { prevItems };\n    },\n    onError: (error: any, newItem: any, context: any) => {\n      queryClient.setQueryData(queryKey, context.prevItems);\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries(queryKey);\n    },\n  };\n};\n\n// the following config hooks are the products of the useQueriesConfig\nexport const useCreateQueryConfig = (queryKey: QueryKey) =>\n  useQueriesConfig(queryKey, (target, old) =>\n    old ? [...old, target] : [target]\n  );\n\nexport const useEditQueryConfig = (queryKey: QueryKey) =>\n  useQueriesConfig(\n    queryKey,\n    (target, old) =>\n      old?.map((item) =>\n        item.id === target.id ? { ...item, ...target } : item\n      ) || []\n  );\n\nexport const useDeleteQueryConfig = (queryKey: QueryKey) =>\n  useQueriesConfig(\n    queryKey,\n    (target, old) => old?.filter((item) => item.id !== target.id) || []\n  );\n\nexport const useReorderSwimlaneQueryConfig = (queryKey: QueryKey) =>\n  useQueriesConfig(queryKey, (target, old) =>\n    reorder({ list: old, ...target })\n  );\n\nexport const useReorderTaskQueryConfig = (queryKey: QueryKey) =>\n  useQueriesConfig(queryKey, (target, old) => {\n    // optimistic updates on the order of tasks\n    const orderedList = reorder({ list: old, ...target }) as Task[];\n    // task sort has also an impact on the swimlane where the task belongs\n    return orderedList.map((item) =>\n      item.id === target.fromId\n        ? { ...item, swimlaneId: target.toSwimlaneId }\n        : item\n    );\n  });\n","import { Typography } from \"antd\";\n\nconst ErrorBox = ({ error }: { error: unknown }) => {\n  //type guard used to explicitly declare a returned value type Error with 'is' as long as it has a message member\n  const isError = (value: any): value is Error => value?.message;\n\n  if (isError(error)) {\n    return <Typography.Text type={\"danger\"}>{error?.message}</Typography.Text>;\n  }\n  return null;\n};\n\nexport default ErrorBox;\n","import React, { ProfilerOnRenderCallback } from \"react\";\n\ntype ProfilerProps = { metadata?: any; phases?: (\"mount\" | \"update\")[] } & Omit<\n  React.ProfilerProps,\n  \"onRender\"\n>;\n\nlet _queue: unknown[] = [];\n// console.count(\"Profiler.tsx\");\n\nexport const Profiler = ({ metadata, phases, ...restProps }: ProfilerProps) => {\n  const reportProfile: ProfilerOnRenderCallback = (\n    id,\n    phase,\n    actualDuration,\n    baseDuration,\n    startTime,\n    commitTime,\n    interactions\n  ) => {\n    if (!phases || phases.includes(phase)) {\n      _queue.push({\n        id,\n        phase,\n        actualDuration,\n        baseDuration,\n        startTime,\n        commitTime,\n        interactions,\n        metadata,\n      });\n    }\n  };\n\n  return <React.Profiler onRender={reportProfile} {...restProps} />;\n};\n\nconst _sendProfilerQueue = () => {\n  if (!_queue.length) {\n    return;\n  }\n  console.count(\"_sendProfilerQueue\");\n\n  const _queueToSend = [..._queue];\n  _queue = [];\n  console.log(_queueToSend);\n};\n\nsetInterval(_sendProfilerQueue, 5000);\n","import React, { Component } from \"react\";\n\ntype FallbackRender = (props: { error: Error | null }) => React.ReactElement;\n\nexport default class ErrorBoundary extends Component<\n  React.PropsWithChildren<{ fallbackRender: FallbackRender }>\n> {\n  state = { error: null };\n  //gets called when errors are thrown by any child component and subsequently passed into the state object in place of the null val\n  static getDerivedStateFromError(error: Error) {\n    return { error };\n  }\n  render() {\n    const { error } = this.state;\n    const { fallbackRender, children } = this.props;\n    if (error) {\n      return fallbackRender({ error });\n    }\n    return children;\n  }\n}\n","import React from \"react\";\nimport { useAuth } from \"hooks/auth\";\nimport FullPageLoader from \"./components/common/FullPageLoader\";\nimport FullPageError from \"./components/common/FullPageError\";\nimport ErrorBoundary from \"app/components/common/ErrorBoundary\";\nimport \"./App.css\";\n\nconst AuthenticatedApp = React.lazy(() => import(\"./AuthenticatedApp\"));\nconst UnauthenticatedApp = React.lazy(() => import(\"./UnauthenticatedApp\"));\n\nfunction App() {\n  //https://kentcdodds.com/blog/authentication-in-react-applications\n  const { user } = useAuth();\n  return (\n    <div className=\"App\">\n      <ErrorBoundary fallbackRender={FullPageError}>\n        <React.Suspense fallback={<FullPageLoader />}>\n          {user ? <AuthenticatedApp /> : <UnauthenticatedApp />}\n        </React.Suspense>\n      </ErrorBoundary>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReactNode } from \"react\";\nimport { QueryClient, QueryClientProvider } from \"react-query\";\nimport { AuthProvider } from \"./AuthContext\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\n\nexport const AppProviders = ({ children }: { children: ReactNode }) => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: {\n        refetchOnWindowFocus: false,\n      },\n    },\n  });\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Router>\n        <AuthProvider>{children}</AuthProvider>\n      </Router>\n    </QueryClientProvider>\n  );\n};\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import \"./wdyr\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"app/App\";\n\nimport { DevTools, loadServer } from \"typezilla-mockserver\";\n\nimport { AppProviders } from \"contexts\";\nimport reportWebVitals from \"reportWebVitals\";\nimport \"antd/dist/antd.less\";\nimport { Profiler } from \"app/components/common/Profiler\";\n//\n\nloadServer(() => {\n  ReactDOM.render(\n    <React.StrictMode>\n      <Profiler id={\"App\"} phases={[\"mount\"]}>\n        <AppProviders>\n          <DevTools />\n          <App />\n        </AppProviders>\n      </Profiler>\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n  );\n});\n\nreportWebVitals();\n","import qs from \"qs\";\nimport { User } from \"types\";\n\nconst api_URL = process.env.REACT_APP_API_URL;\nconst localStorageKey = \"__auth__provider__token__\";\n\ninterface Config extends RequestInit {\n  params?: object;\n  token?: string;\n}\n//centralize requests except auth\nexport const configureFetch = async (\n  endpoint: string,\n  { params, token, headers, ...restConfig }: Config = {}\n) => {\n  const config = {\n    method: \"GET\",\n    headers: {\n      Authorization: token ? `Bearer ${token}` : \"\",\n      \"Content-Type\": params ? \"application/json\" : \"\",\n    },\n    //overrides the method prop depending on the input config\n    ...restConfig,\n  };\n  if (config.method.toUpperCase() === \"GET\") {\n    endpoint += `?${qs.stringify(params)}`;\n  } else {\n    config.body = JSON.stringify(params || {});\n  }\n\n  const response = await window.fetch(`${api_URL}/${endpoint}`, config);\n  if (response.ok) {\n    return await response.json();\n  } else {\n    if (response.status === 401) {\n      await logout();\n      window.location.reload();\n      return Promise.reject({ message: \"Please log in again\" });\n    } else {\n      return Promise.reject(await response.json());\n    }\n  }\n};\n\n//auth separately\nexport const getToken = () => window.localStorage.getItem(localStorageKey);\nexport const handleUserResponse = ({ user }: { user: User }) => {\n  window.localStorage.setItem(localStorageKey, user.token || \"\");\n  return user;\n};\n\nexport const login = async (params: { username: string; password: string }) => {\n  const response = await fetch(`${api_URL}/login`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(params),\n  });\n  if (response.ok) {\n    return handleUserResponse(await response.json());\n  } else {\n    return Promise.reject(await response.json());\n  }\n};\n\nexport const register = async (params: {\n  username: string;\n  password: string;\n}) => {\n  const response = await fetch(`${api_URL}/register`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(params),\n  });\n  if (response.ok) {\n    return handleUserResponse(await response.json());\n  } else {\n    return Promise.reject(await response.json());\n  }\n};\n\nexport const logout = async () =>\n  window.localStorage.removeItem(localStorageKey);\n"],"sourceRoot":""}